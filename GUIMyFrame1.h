#ifndef __GUIMyFrame1__
#define __GUIMyFrame1__

/**
@file
Subclass of MyFrame1, which is generated by wxFormBuilder.
*/

#include "GUI.h"

//// end generated include

#include <wx/wx.h>
#include <wx/dcmemory.h>
#include <wx/dcclient.h>
#include <wx/dcbuffer.h>
#include <vector>

class LoadingDialog : public wxDialog
{
public:
	wxGauge* progressBar;

	LoadingDialog(wxWindow* parent)
		: wxDialog(parent, wxID_ANY, _("Proszê czekaæ"), wxDefaultPosition, wxDefaultSize, wxCAPTION | wxSTAY_ON_TOP)
	{
		wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);
		wxStaticText* label = new wxStaticText(this, wxID_ANY, _("Trwa generowanie obrazów"));
		progressBar = new wxGauge(this, wxID_ANY, 100, wxDefaultPosition, wxDefaultSize, wxGA_HORIZONTAL);
		progressBar->SetValue(0);

		sizer->Add(label, 0, wxALL | wxALIGN_CENTER, 10);
		sizer->Add(progressBar, 0, wxALL | wxEXPAND, 10);

		SetSizerAndFit(sizer);
		Centre();
	}
};


/** Implementing MyFrame1 */
class GUIMyFrame1 : public MyFrame1
{
	protected:
		// Handlers for MyFrame1 events.
		void scrollChangeAxisNumber( wxScrollEvent& event );
		void scrollRotate( wxScrollEvent& event );
		void translateX( wxScrollEvent& event );
		void translateY( wxScrollEvent& event );
		void changeInterpolator( wxCommandEvent& event );
		void drawOnChange( wxCommandEvent& event );
		void loadImage( wxCommandEvent& event );
		void clickSaveSeries( wxCommandEvent& event );
		void clickSave( wxCommandEvent& event );
		void clickDraw( wxCommandEvent& event );
	public:
		/** Constructor */
		GUIMyFrame1( wxWindow* parent );
	//// end generated class members
		const wxWindowID id = wxNewId();
		wxImage img;
		wxImage imgCopy;
		wxImage imgOriginal;
		bool linear = true;
		bool onChange = false;
		std::vector<double> axisVect;
		int a;
		double angle;
		void Repaint();
		void setAxis(int number);
		void drawAxis(wxClientDC &dc);
		void drawKaleidoscope();
		void translateX();
		void translateY();
		void resetOptions();
		float cubicInterpolate(float p[4], float x);
		float bicubicInterpolate(float patch[4][4], float x, float y);
		wxImage RotateImageCubic(const wxImage& source, double angleDegrees);
		wxImage RotateImageLinear(const wxImage& source, double angleDegrees);
		wxImage MirrorRightHalf(const wxImage& source);
		void generateSeries(wxString path);
		LoadingDialog* dlg;
		void OnThreadCompletion(wxCommandEvent& event);
		void UpdateProgressBar(wxCommandEvent& event);
		const long ID_UPDATE_PROGRESS = wxNewId();


};

class WorkerThread : public wxThread
{
public:
	WorkerThread(GUIMyFrame1* parent, const wxString& path)
		: wxThread(wxTHREAD_DETACHED), m_parent(parent), m_path(path) {}

	virtual wxThread::ExitCode Entry() {
		m_parent->generateSeries(m_path);
		wxQueueEvent(m_parent, new wxCommandEvent(wxEVT_COMMAND_BUTTON_CLICKED, m_parent->id));
		return (wxThread::ExitCode)0;
	}

private:
	GUIMyFrame1* m_parent;
	wxString m_path;
};

#endif // __GUIMyFrame1__
